<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">

    <title></title>
    <style>

    /* 다음 교육을 위해서 가려두자
      #hoverTest:hover{
        color:red;
      }
      :target{
        border:1px solid blue;
      }
      :focus{
      background-color: yellow;
      }
      :in-range{
        background-color: green;
      }
      :out-of-range{
        background-color: red;
      }
      :disabled{
        background-color: brown;
      }
      :enabled{
        border: 2px solid gray;
      }
      :read-only{
        border-color: yellow;
      }
      :checked{
        width:20px;
        height:20px;
      } */

    </style>
  </head>
  <body>
    <main>
      <h1>form 연습하기</h1>
      <h2>css 의사클래스(pseudo classes)</h2>
      <p>상태조건에 맞는 해당 요소를 택하는 선택자 느낌?</p>
      <h3>1.요소의 동적 의사 클래스 (dynamic pseudo-classes)</h3>
      <ul>
        <li id="hoverTest">:hover = 마우스 커버가 올라와 있는(동적상황이 맞아 떨어지는) 요소
          <br>(광역으로 적용시킬수도 있지만 지금처럼 #hoverTest만 특정후 작업 가능)
        </li>
        <li> <a href="#">:link = 걸어둔 링크에 아직 방문하지 않은 요소(a태그 파란색)</a> </li>
        <li> <a href="">:visited = 걸어둔 링크에 방문한 요소(a태그 보라색)</a> </li>
        <li> <a href="#">:active = 활성된 즉, 클릭이 눌려있는 요소(마우스 다운시 a태그 빨간색)</a> </li>
        <li> <a href="#hoverTest">:target = 현재 타겟이 된 즉, 링크에 잡혀있는 요소(href="css선택자")
        <br>(트리거는 해당링크 클릭)</a> </li>
      </ul>

      <h3>2.요소의 상태 의사 클래스 ([Form] UI element state pseudo-classes)</h3>
        <ul>
          <li>:focus = 초점이 맞춰진 input 입력요소<br>
          <input type="text"> </li>
          <li>:in-range = value가 범위내의 값인 요소(type이 number인 iput요소의 range에 따른 조작)<br>

        :out-of-range = value가 범위밖의 값이 아닌 요소<br>
          <input type="number" value="15" min="5" max="10"></li>
          <li>:disabled = 입력요소가 장애판정 된 요소(데이터가 서버로 전달되지 않는다. 즉 고장난 input요소)<br>
            <input type="text" disabled></li>

          <li>:enabled = 사용할 수 있는 요소</li>
          <li>:read-only = readonly가 있는 (혹은 수정불가 맞나?) 입력요소</li>
          <input type="text" readonly value="수정X">
          <li>:read-write = required 속성을 가지는 input 요소</li>
          <li>:optional = required 속성을 가지는 input 요소 </li>
          <li>:valid = 유효한 값을 가지는 input 요소 </li>
          <li>:invalid = 유효하지 않은 값을 가지는 input 요소</li>
          <li>:checked = 체크된 상태의 input 요소
            <label>test <input type="radio" >  </label> </li>
        </ul>
        <h2>Select 입력요소 연습</h2>
        <p>Select요소는 options라는 선택속성이 있다.</p>

          <br>options == (document.qeurySelectorAll("특정select option"))
          <br>options.selectedIndex == 옵션들 중 선택된 옵션의 index를 반환
          <br>options[index].text == innerText

        <p>
          <label>
            <!-- onchange="console.table(this.options.selectedIndex)" -->
            <select name="alphabet" onchange="alphaChange(this)">
              <option value="A">a</option>
              <option value="B">b</option>
              <option value="C">c</option>
              <option value="D">d</option>
              <option value="E">e</option>
            </select>
        </label>
        <span>선택된옵션의 index: </span>
        <b id="selectedOption"></b>
      </p>
<script>
  function alphaChange(xxxxx){
    var that1 = xxxxx.options.selectedIndex;
    var that3 = xxxxx.options[that1].value;
    var that4 = xxxxx.options[that1].text;
    var that2 = document.getElementById("selectedOption");

    that2.innerText = that1+","+that3+","+that4;
  }
</script>
    <p>select multiple : 여러 옵션을 선택하여 서버에 제출 할 수 있다.
     <br>하지만 선택된 여러 옵션 전체를 일반적인 방법으로 알 수가 없다.
     <br>(선택된 옵션들 중 첫번째만 반환 하는 문제 때문? console.log로 다 찾아지는데..?)
     <br> :checked 로 선택된 대상들을 모두 쉽게 찾을 수 있다.
    </p>
    <p>
      <label>
        멀티옵션 선택:
        <form class="" action="" method="POST">

          <p>과제!!!!!!!
            :멀티로 선택된 녀석들의 세부 정보(index, value, text)모두를 출력해봐!
          </p>

          <!-- 선택된 option이 복수이고 다시 각각에 종속된 정보들 역시 복수 -->
          <!-- 이때 문제상황.. 즉 위의 함수처럼 options[index]로 하자니.. 이때 index 자체가 복수.. -->
          <!-- 그의 각각에 달린 정보들이 다르니 정보를 한번에 출력 할 수 있을리가 .. 
            아항!
          복수의 대상에서 대상 하나하나를 순서대로 불러오는 반복문을 사용!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-->


          <!-- 이걸로 뭘 확인한다고? HTTPRequest(요청).getParameters("selectMulti")=["B","C","D"]
            get방식 : 서버에 parameter를 보내어 요청합니다??
            um,.네트워크 간다음에 해더가서 뭔가들을 확인하네..?
          POST : 서버 요청시 해더의 메타정보로 form data를 추가할 수 있다 -->
          <!-- console.log(this.querySelectorAll(':checked'))" -->

        <select name="selectMulti" multiple onchange="multiTest(this)">
          <option value="A">a</option>
          <option value="B">b</option>
          <option value="C">c</option>
          <option value="D">d</option>
          <option value="E">e</option>
          <option value="F">f</option>
        </select>
        <button type="submit" name="button">제출</button>
        </form>
      </label>
    <strong>제출될 데이터를 확인하세요: </strong>
    <br><span id="multipleOption"></span>
        </p>

<!-- ([{index:0, value=A, text=a}{index:1, value=B, text=b}]) -->

<script>
  function multiTest(xxxxx){
var that1 = xxxxx.querySelectorAll(":checked");

// var that2 = document.getElementById("multipleOption");
// var that3 = xxxxx.options[that1].value;
// var that4 = xxxxx.options[that1].text;
// console.log(that1)
// that2.innerText = that1+","+that3+","+that4;
   var printText="";
    printText+="[";
//for(var i=0; i<that1.length; i++){}
//that1.next()->  that1[a,b,c,d]의 [0]에 위치하며 해당 위치의 값이 있으면 그 값으로 for이하 구문을 실행하며 true(코인)를 반환
 // --> 반환된 코인 true로 한칸 이동하여 [1]로 위치하게 되며 역시 같은 작업을 반복-> ... 없으면? 코인 오링났어~ 종료    /
// ** ob은 구 반복문(for)에서의 인덱스 i와는 조금 다른 개념, 객체라고 함. i 인덱스 활용이 익숙치 않으면 이거 괜찮은데?
  for(var ob of that1){
    printText+="{"
    printText+="index:"+ob.index+",";
    printText+="value:"+ob.value+",";
    printText+="text:"+ob.text;
    printText+="}"
  }
  printText+="]"
  document.getElementById("multipleOption").innerText=printText;
  }
</script>
      <h3>checkbox 연습하기</h3>
      <h4>선택된 박스의 value 확인하기</h4>

      <p>과제!!!!!!!
        : 전체선택 클릭시 위의 체크박스가 몇개던 간에 모두 체크되도록!!!
        그리고 check박스의 선택된 항목들 출력</p>

      <form class="asdf" action="index.html" method="post">
        <label>
          체크1:
          <input type="checkbox" name="test" value="box1" onchange="printChecked(this)">
        </label>
        <label>
          체크2:
          <input type="checkbox" name="test" value="box2" onchange="printChecked(this)">
        </label>
        <label>
          전체선택:
          <input type="checkbox" name="selectAll" value="all" onclick="allCheck(this)">
        </label>
        <p>선택된 항목: <span id="printer"></span> </p>
        

          <!-- 음.. check가 됐고 안됐고 자체를 데이터화 할 수 있나? 
          아 먼저 체크 여부의 데이터를 가져올 것이 아니고 'checked'를 통해서 
          해당 데이터를 접근 할 수 있다보니 간단히 서로의 상태가 같아지도록 명령어만 넣어주면 되는거네  -->

          <!-- 출력은 어떻게? 출력하고 싶은 문구(데이터)를 찾아 먼저 대상화(변수지정, 반복문을 많이활용)
          이때 문제는... 그 문구가 체크된 녀석들의 데이터인데 아 체크된 녀석들 찾을 수 있었지 ㅇㅋ 
        아니 그런데 대상이 복수로 불러와지니 대상 하나하나를 순서대로 불러오는 반복문을 사용-->
          <!-- 그후 대상을 출력장소의 innerText가 되도록 만들면 되지~!
          그 과정은? 데이타 대상을 담을 변수를 선언한뒤 변수에 반복문을 이용하여 정보들을 
          text로 담아 innerText=변수 로 마무리 -->

<script>

function allCheck(xxxxx){
var that1 = document.getElementsByName('test');

for(YYYY of that1){
 YYYY.checked = xxxxx.checked;
}
}


function printChecked(xxxxx){
 var that1 = xxxxx.form.querySelectorAll(":checked")
 var that2 = document.getElementById("printer")

// 아... 여기서 계속 했던 실수하나, xxxxx.queryselectorall하면
// 자동으로 xxxxx의 부모요소에서 찾을 줄 알았는데 바보 같은 착각

 console.log(that2)
var poo1 = "";
poo1+="["

for(var ob of that1){
  poo1+="{";
  poo1+="value:"+ob.value;
  poo1+="}"
}

poo1+="]";

document.getElementById("printer").innerText=poo1;

}


</script>
      </form>
    </main>
  </body>
</html>
